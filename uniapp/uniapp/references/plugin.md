# Uniapp - Plugin

**Pages:** 11

---

## uni-app官网

**URL:** https://uniapp.dcloud.net.cn/uni_modules

**Contents:**
- # 快速体验
- # 看视频，10分钟了解uni-app
- # 为什么要选择uni-app？
      - 开发者/案例数量更多
      - 平台能力不受限
      - 性能体验优秀
      - 周边生态丰富
      - 学习成本低
      - 开发成本低
- # 功能框架图

uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、鸿蒙Next、Web（响应式）、以及各种小程序（微信/支付宝/百度/抖音/飞书/QQ/快手/钉钉/淘宝/京东/小红书）、快应用、鸿蒙元服务等多个平台。

DCloud公司拥有900万开发者、数百万应用、12亿手机端月活用户、数千款uni-app插件、70+微信/qq群，开发者可以放心选择。

uni-app在手，做啥都不愁。即使不跨端，uni-app也是更好的小程序开发框架（详见 ）、更好的App跨平台框架、更方便的H5开发框架。不管领导安排什么样的项目，你都可以快速交付，不需要转换开发思维、不需要更改开发习惯。

一套代码编到十几个平台，这不是梦想。眼见为实，扫描以下二维码，亲自体验最全面的跨平台效果！

注： - 某些平台不能提交简单demo，故补充了一些其他功能；hello uni-app示例代码可从 github 获取 - 快应用仅支持 vivo 、oppo、华为 - 360小程序仅 windows平台支持，需要在360浏览器中打开 - uni-app 已支持纯血鸿蒙开发，详见 鸿蒙开发专题。

我们精心准备了一个简单的十分钟介绍视频，方便你快速了解uni-app的主要特征：

uni-app在开发者数量、案例、跨端抹平度、扩展灵活性、性能体验、周边生态、学习成本、开发成本等8大关键指标上拥有更强的优势。

数百万应用、uni统计月活12亿、70+微信/qq群、更高的百度指数

在跨端的同时，通过条件编译+平台特有API调用，可以优雅的为某平台写个性化代码，调用专有能力而不影响其他平台。

加载新页面速度更快、自动diff更新数据。

App端支持原生渲染，可支撑更流畅的用户体验。

微信生态的各种sdk可直接用于跨平台App。

基于通用的前端技术栈，采用vue语法+微信小程序api，无额外学习成本。

不止开发成本，招聘、管理、测试各方面成本都大幅下降。

HBuilderX是高效开发神器，熟练掌握后研发效率至少翻倍（即便只开发一个平台）。

从下面uni-app功能框架图可看出，uni-app在跨平台的过程中，不牺牲平台特色，可优雅的调用平台专有能力，真正做到海纳百川、各取所长。

uni-app实现了一套代码，同时运行到多个平台；如下图所示，一套代码，同时运行到iOS模拟器、Android模拟器、web、微信开发者工具、支付宝小程序Studio、百度开发者工具、抖音开发者工具、QQ开发者工具（底部每个终端选项卡，代表1个终端模拟器）：

---

## uni-app官网

**URL:** https://uniapp.dcloud.net.cn/plugin/plugin-ext-introduction.html

**Contents:**
- # 插件市场介绍
- # 付费插件
      - 本页导读

DCloud有活跃的插件市场，https://ext.dcloud.net.cn/ ，并提供了变现、评价等机制。

DCloud插件市场将插件分为前端组件、JS SDK、uni-app前端模板、App原生插件、uniCloud等7大类、20多个子类，你可以根据需要进行筛选查询。

DCloud的插件市场还提供了优秀作者及热门插件排行榜，欢迎大家客观评价自己使用过的插件，帮助作者完善插件，共同创造正向的插件市场。

除了排行榜这种荣誉激励，DCloud还支持对uniCloud插件、uts/原生插件设置付费销售，对免费插件设置先看广告后下载，帮助插件作者进行技术变现。

插件市场的付费插件支持UTS插件、App原生插件、uniCloud、前端组件三大分类。

UTS插件、App原生插件、前端组件是客户端插件，UTS插件和App原生插件付费插件仅支持购买后提交云端打包，前端组件还支持发行web，三种分类购买时均需绑定项目appid及包名。

uniCloud插件是云端插件，绑定uniCloud服务空间的spaceId。

uniCloud、UTS插件及前端组件三个分类的付费模式分为 普通授权版 和 源码授权版。

提供2个版本是为了给插件交易提供更多选择，在产权保护、插件售价方面取得平衡。

普通授权版的价格相对便宜，其中会有部分或全部源码不可见。uts插件是全部uts代码不可见，uniCloud插件则取决于插件作者的配置那些云函数加密。uniCloud分类会在插件主页会显示哪些云函数被加密了。

上表中可以看出，插件用户支付不同的价格，购买到的授权内容也不一样。并且源码授权版的购买流程也更复杂一些。

但两个版本的功能是一样的。因为它们实际上是一套代码，只是源码可见还是不可见而已。

插件作者在上传插件时，可以只选择普通授权版，源码授权版是可选项。插件作者也可以拒绝与某个潜在买家签订源码授权版的电子合同。

插件作者可以配置需加密文件的清单，除非插件用户购买源码授权版，否则看不到加密部分的文件源码。不管是试用还是购买普通授权版，都看不到加密文件的源码。

UTS插件针对项目进行申请试用。试用虽然下载了插件，但插件内容对试用者而言不可见。试用的插件只能用于打包自定义基座，不能用于正式发布。试用没有有效期限制。

App原生插件针对项目进行申请试用，插件不下载，试用的插件只能用于云端打包自定义基座，不能用于正式发布。试用没有有效期限制。

uniCloud插件针对服务空间进行申请试用，试用时被加密的云函数对试用者而言不可见。试用期可以加密云函数部署到指定的服务空间进行体验，但试用期结束后这些加密云函数会被自动删除。（试用期一般是7天，具体见试用时界面向导的提示）

前端组件针对项目进行申请试用，试用虽然下载了插件，但插件内容对试用者而言不可见。试用的插件只能用于本地运行或打包自定义基座，不能用于正式发布。试用没有有效期限制。

---

## uni-app官网

**URL:** https://uniapp.dcloud.net.cn/plugin/uni_modules.html

**Contents:**
- # uni_modules
- # 什么是 uni_modules
  - # uni_modules的优势
- # 目录结构
  - # 项目插件的uni_modules
  - # 非项目插件的uni_modules
    - # uts插件
- # HBuilderX中使用 uni_modules 插件
  - # 下载uni_modules插件
  - # 安装uni_modules插件依赖

主流的语言/平台，都有自己包管理方案，js有npm、yarn或pnpm、Android有仓储、iOS有cocoapods、鸿蒙有ohpm、dart有pub。。。

uni-app是大一统开发，包括客户端和uniCloud服务器。在客户端部分包括web、Android、iOS、各家小程序。

在uni-app中可以调用npm库，可以调用Android仓储里的aar，可以调用iOS的cocoapods里framework，以及鸿蒙的ohpm。

甚至uts语言本身也可以编译为js、kotlin、swift、ArkTS。

那么uni-app的开发者，需要一个大一统的包管理方案，那就是uni_modules。

uni_modules是uni-app的包管理方案（HBuilderX 3.1.0+支持），它是一个海纳百川型的设计，

由于uni-app有自己的项目目录结构规范（uni-app详见、uni-app x详见 ）， 所以你可以简单理解，把一个项目的这些工程目录都挪到了一个uni_modules下，打包成了一个模块，这里面只要符合uni-app规范的文件都可以放。

与之前插件市场的普通插件相比，uni_modules有何优势？

有node_modules了，为何还发明一个uni_modules的轮子？

除了发布插件，uni_modules同时也是一种大型工程的模块分割方案。比如一个旅游应用，可以把机票、酒店、火车票、自由行等模块分拆成不同的uni_modules，由不同的部门来开发。

uni_modules插件如果是项目类型的插件，只需要在项目的根目录下放一个符合uni_modules规范的package.json。

右键点击这个package.json，即可对这个项目插件进行更新、或发布到插件市场。

比如uni-admin 、uni-starter ，都可以通过这种方式更新。

如果是非项目类型的插件，比如组件、js sdk、页面模板、云函数，则需要放置在项目的uni_modules目录下。

此时uni_modules目录下的目录结构和uni-app的项目结构是一致的，如下：

也就是uni_modules目录下相当于复制一遍uni-app的项目结构。

在HBuilderX中，uni_modules下如果包含了uniCloud目录的内容，会被以引用的方式，显示到主项目根目录下的uniCloud中。此时文件前的图标左下角会显示一个快捷方式箭头。

如下图，项目中有一个uni_modules名为uni-config-center，它下面包含了名为uni-config-center的公共模块。所以在项目根目录的公共模块目录common下，也会多出一个uni-config-center。

HBuilderX 中打开配有引用图标指示的文件，会打开原始地址。

在uni_modules的utssdk目录，可以放置uts插件。

uts插件是非常重要的一种跨端插件。它支持API插件和组件插件，可通过原生能力，封装后给uni-app(x)扩展API和组件。

在utssdk目录下，然后可以新建app-android、app-ios、app-harmony、web、mp-weixin等目录，每个目录下可以存放不同客户端平台的专用代码。

在app-android、app-ios、app-harmony目录，可以放置Android原生的aar、so库，iOS原生的framework，鸿蒙的har，也支持配置Android仓储、iOS的cocoapods、鸿蒙的ohpm。

在web和mp目录下，也支持放置npm库。

虽然utssdk目录下有这么多平台专用目录，但utssdk的根目录下可以放置一个interface.uts的声明。这个文件统一了不同平台的接口，把不同平台的原生能力，转换为统一的API或组件，给前端开发者使用。

这是非常重要的设计，这也是uni-app区别于其他跨平台工具的重要特色。

以获取电量的API为例，uni.getBatteryInfo()，在根目录的interface.uts中定义了api的对外暴露接口、定义统一的错误码，然后在各个客户端平台的目录中，实现电量获取这个API。

uni.getBatteryInfo的插件和源码详见：https://ext.dcloud.net.cn/plugin?id=9295

uts插件开发的详细指南见：https://doc.dcloud.net.cn/uni-app-x/plugin/uts-plugin.html

使用 import 导入uts插件时，仅支持导入到插件根目录，不支持导入插件内部的文件。

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

uni_modules插件目录是独立存在的，如果您不再需要该插件，可以直接删除该插件目录。

如果你是插件作者，需要了解uni_modules的配置。如果是使用者，可无需关心本章节。

package.json在每个uni_modules插件中都必须存在，包含了插件的基本信息。以下是package.json的详细配置说明（注意：平台兼容性相关配置有变更，需区分HBuilderX版本）。 其中有些配置仅发布到插件市场时需要，如果你做的uni_modules并不对外发布到插件市场，相关字段可忽略。

为更好的区分uni_modules插件对各平台的支持，从HBuilderX 4.71起，平台兼容性针对uni-app及uni-app x两个维度做了拆分，对各平台的定义做了调整，并新增了多语言、暗黑模式、宽屏模式的定义，具体规范变更如下：

示例源码如下，请查看 pre > code 标签中的内容

平台兼容性规范改版后，使用HBuilderX 4.71之前的版本发布到DCloud插件市场 时，插件市场会自动将平台兼容性转换为新版规范以做兼容。为了有更准确的平台兼容性设置，建议升级HBuilderX使用HBuilderX 4.71+来操作发布。

除了以上变更为，其余配置和HBuilderX 4.71之前版本一致，HBuilderX 4.71之前版本完整规范如下：

示例源码如下，请查看 pre > code 标签中的内容

HBuilderX 4.71之前版本发布界面

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

uni_modules.config.json在项目根目录，可以配置插件更新后的触发脚本（通常用于执行自定义的自动化任务），插件uniCloud支持的服务空间。以下是uni_modules.config.json的详细配置说明

示例源码如下，请查看 pre > code 标签中的内容

uni_modules插件发布到插件市场是通常需要忽略掉一些目录或文件，比如unpackage、.hbuilderx、node_modules等，这时可以通过npmignore文件来实现文件的忽略。

文件名：.npmignore，注意开头有个点。典型的npmignore文件内容如下：

示例源码如下，请查看 pre > code 标签中的内容

过去，插件作者提供页面类插件时，需要在文档中手动告知使用者在pages.json中注册哪些页面。如：

示例源码如下，请查看 pre > code 标签中的内容

pages_init.json解决了这个烦恼。

当uni_modules插件根目录下存在pages_init.json文件，在插件导入工程时，会弹出一个合并页面路由的pages.json修改界面。插件使用者点击确认按钮即可完成插件页面向项目pages.json的注册。

示例源码如下，请查看 pre > code 标签中的内容

在uni-app项目根目录下，创建uni_modules目录，在HBuilderX中可以项目右键菜单中点击新建uni_modules目录

通过 uni_modules->dependencies 配置三方uni_modules插件依赖

示例源码如下，请查看 pre > code 标签中的内容

当您的插件开发完毕，可以直接发布到插件市场 供其他人免费或付费使用，插件市场提供了变现、评价等机制，优秀的插件作者可以做到月入数万元。

当您的插件发布到插件市场后，如果需要调整插件市场上的一些基本信息，比如插件中文名称，描述，关键词，readme.md等，可以直接在插件目录右键修改插件基本信息

当您的插件增加了新的功能或修复了Bug，需要发布新版本时，操作与第一次发布一样，可以直接在插件目录右键发布到插件市场

示例源码如下，请查看 pre > code 标签中的内容

**Examples:**

Example 1 (unknown):
```unknown
uni_modules
```

Example 2 (unknown):
```unknown
uni_modules
```

Example 3 (unknown):
```unknown
uni_modules
```

Example 4 (unknown):
```unknown
uni_modules
```

---

## uni-app官网

**URL:** https://uniapp.dcloud.net.cn/plugin/uts-ios-cocoapods.html

**Contents:**
- # 在 uts 插件中使用 CocoaPods 依赖
- # CocoaPods 环境配置
  - # CocoaPods安装
    - # CocoaPods 安装成功
    - # CocoaPods 安装失败
  - # 升级 Gem
  - # 升级 Ruby
    - # 通过 RVM 升级 Ruby
    - # 通过 Homebrew 升级 Ruby
- # 常见问题

本文旨在帮助 uts 插件开发者和使用者，快速了解 uts 插件中配置使用 CocoaPods 依赖的问题。 包括在Mac系统真机运行时如何配置 CocoaPods 环境，以及 CocoaPods 使用过程中常见错误处理

此功能 HBuilder X 3.8.5+ 版本支持

在 uts 插件中使用 CocoaPods 依赖库，需要在 config.json 中 dependencies-pods 节点做相应配置，下面是配置示例：

示例源码如下，请查看 pre > code 标签中的内容

注意：拷贝以上代码时请手动删除注释，实际项目中config.json中不能包含注释信息

在Mac系统上使用标准基座真机运行时才需要配置 CocoaPods 环境， 使用自定义调试基座提交云端打包则可以不配置 CocoaPods 环境。 在Windows系统上不支持 CocoaPods 环境，只能提交云端打包使用自定义调试基座。

正常安装 CocoaPods 需要在终端执行下述命令

示例源码如下，请查看 pre > code 标签中的内容

这会耗费一段时间，完成后可查看 cocoapods 的版本号

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

如：/Users/dcloud/.rvm/rubies/ruby-3.0.0/bin/pod

至此 CocoaPods 已经安装完成，可以尝试 Search 下一 pod 库：

示例源码如下，请查看 pre > code 标签中的内容

如果执行 pod search 失败，说明当前网络不能正常访问 github 或者 cdn, 更多信息详见无法访问 github , CDN错误 。

示例源码如下，请查看 pre > code 标签中的内容

说明缺少activesupport插件，在终端执行以下命令

示例源码如下，请查看 pre > code 标签中的内容

插件安装成功后再次执行 sudo gem install cocoapods 安装 CocoaPods.

示例源码如下，请查看 pre > code 标签中的内容

Gem 是管理 Ruby 标准包,如果 Gem 版本过低可能造成无法安装 CocoaPods,升级 Gem 使用下述命令

示例源码如下，请查看 pre > code 标签中的内容

MacOS 会自带 Ruby，但可能系统的Ruby版本过低，导致无法安装 CocoaPods, 可通过以下方式更新 Ruby

示例源码如下，请查看 pre > code 标签中的内容

Ruby 的升级有以下两种常见的方式，可根据自己的需要任选其中一种：

示例源码如下，请查看 pre > code 标签中的内容

这个命令会从 RVM 官网下载安装脚本并运行。安装完成后，需要在终端中执行以下命令以便让 RVM 生效：

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

安装完成后，ruby 默认使用的是系统自带的版本

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

升级完 Gem 和 Ruby 后，在终端重新输入如下命令安装 CocoaPods。

示例源码如下，请查看 pre > code 标签中的内容

安装完成后，可如上文所示，查看 CocoaPods 版本号。

错误信息：uni_module xxxx (iOS) 存在pod三方依赖库，请先安装 CocoaPods！ 说明：出现此错误是因为当前环境没有安装 CocoaPods 处理方法： 请参照上述章节描述的方式安装 CocoaPods 工具。

错误信息：CocoaPods could not find compatible versions for pod "xxx" 或者 None of your spec sources contain a spec satisfying the dependency: 报错示例：

示例源码如下，请查看 pre > code 标签中的内容

说明：出现此错误是因为执行 pod install 时找不到指定依赖。

示例源码如下，请查看 pre > code 标签中的内容

说明： 出现此错误是因为当前网络无法正常访问 github

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

说明： 出现此类错误是因为网络网络问题无法正常访问 CDN 服务器

**Examples:**

Example 1 (json):
```json
{
	"deploymentTarget": "9.0",   // 可选，插件支持的最低 iOS 版本  默认：9.0"
	"dependencies-pod-sources": [ //可选, 指定source 源, 可指定多个。HBuilderX 4.61+ 版本支持
	  "https://github.com/test/test-specs.git"
	],
	"dependencies-pods": [ // 可选, 需要依赖的 CocoaPods 库, HBuilderX 3.8.5+ 版本支持
	{
		"name": "WechatOpenSDK",
		"version": "2.0.2",
		"source": "https://github.com/test/test-specs.git" //可选，直接指定某个库的spec源地址，HBuilderX 4.61+ 版本支持
	}, {
		"name": "Alamofire",
		"version": "5.7.3", //配置 repo 时可不指定 version
		"repo": {  // 可选，配置 pod 库为指定仓库，配置repo时，应至少指定 git。 （HBuilder X 3.8.10+ 版本新增支持）
			"git": "https://github.com/test/Alamofire.git", //指定 pod 库的仓库地址
			"tag": "5.7.3", // 指定该 pod 库仓库的 tag
			"branch": "dev", // 指定该 pod 库仓库的分支
			"commit": "b309714f3aa5091f1ce8d932094b7594ed7acad9" // 指定该 pod 库仓库的某次commit
		}
	}]
}
```

Example 2 (json):
```json
{
	"deploymentTarget": "9.0",   // 可选，插件支持的最低 iOS 版本  默认：9.0"
	"dependencies-pod-sources": [ //可选, 指定source 源, 可指定多个。HBuilderX 4.61+ 版本支持
	  "https://github.com/test/test-specs.git"
	],
	"dependencies-pods": [ // 可选, 需要依赖的 CocoaPods 库, HBuilderX 3.8.5+ 版本支持
	{
		"name": "WechatOpenSDK",
		"version": "2.0.2",
		"source": "https://github.com/test/test-specs.git" //可选，直接指定某个库的spec源地址，HBuilderX 4.61+ 版本支持
	}, {
		"name": "Alamofire",
		"version": "5.7.3", //配置 repo 时可不指定 version
		"repo": {  // 可选，配置 pod 库为指定仓库，配置repo时，应至少指定 git。 （HBuilder X 3.8.10+ 版本新增支持）
			"git": "https://github.com/test/Alamofire.git", //指定 pod 库的仓库地址
			"tag": "5.7.3", // 指定该 pod 库仓库的 tag
			"branch": "dev", // 指定该 pod 库仓库的分支
			"commit": "b309714f3aa5091f1ce8d932094b7594ed7acad9" // 指定该 pod 库仓库的某次commit
		}
	}]
}
```

Example 3 (json):
```json
{
	"deploymentTarget": "9.0",   // 可选，插件支持的最低 iOS 版本  默认：9.0"
	"dependencies-pod-sources": [ //可选, 指定source 源, 可指定多个。HBuilderX 4.61+ 版本支持
	  "https://github.com/test/test-specs.git"
	],
	"dependencies-pods": [ // 可选, 需要依赖的 CocoaPods 库, HBuilderX 3.8.5+ 版本支持
	{
		"name": "WechatOpenSDK",
		"version": "2.0.2",
		"source": "https://github.com/test/test-specs.git" //可选，直接指定某个库的spec源地址，HBuilderX 4.61+ 版本支持
	}, {
		"name": "Alamofire",
		"version": "5.7.3", //配置 repo 时可不指定 version
		"repo": {  // 可选，配置 pod 库为指定仓库，配置repo时，应至少指定 git。 （HBuilder X 3.8.10+ 版本新增支持）
			"git": "https://github.com/test/Alamofire.git", //指定 pod 库的仓库地址
			"tag": "5.7.3", // 指定该 pod 库仓库的 tag
			"branch": "dev", // 指定该 pod 库仓库的分支
			"commit": "b309714f3aa5091f1ce8d932094b7594ed7acad9" // 指定该 pod 库仓库的某次commit
		}
	}]
}
```

Example 4 (json):
```json
{
	"deploymentTarget": "9.0",   // 可选，插件支持的最低 iOS 版本  默认：9.0"
	"dependencies-pod-sources": [ //可选, 指定source 源, 可指定多个。HBuilderX 4.61+ 版本支持
	  "https://github.com/test/test-specs.git"
	],
	"dependencies-pods": [ // 可选, 需要依赖的 CocoaPods 库, HBuilderX 3.8.5+ 版本支持
	{
		"name": "WechatOpenSDK",
		"version": "2.0.2",
		"source": "https://github.com/test/test-specs.git" //可选，直接指定某个库的spec源地址，HBuilderX 4.61+ 版本支持
	}, {
		"name": "Alamofire",
		"version": "5.7.3", //配置 repo 时可不指定 version
		"repo": {  // 可选，配置 pod 库为指定仓库，配置repo时，应至少指定 git。 （HBuilder X 3.8.10+ 版本新增支持）
			"git": "https://github.com/test/Alamofire.git", //指定 pod 库的仓库地址
			"tag": "5.7.3", // 指定该 pod 库仓库的 tag
			"branch": "dev", // 指定该 pod 库仓库的分支
			"commit": "b309714f3aa5091f1ce8d932094b7594ed7acad9" // 指定该 pod 库仓库的某次commit
		}
	}]
}
```

---

## uni-app官网

**URL:** https://uniapp.dcloud.net.cn/plugin/sell.html

**Contents:**
- # 插件变现
- # 付费插件销售
  - # 版权保护和试用机制
- # 查看收益
- # 账单结算
      - 本页导读

插件市场为插件作者提供多种变现方式，包括：

插件作者需要在插件市场实名注册并填写财务信息，否则DCloud无法把收益支付给插件作者。

插件市场支持对uniCloud插件、app的uts/原生插件、前端组件插件设置付费销售其中：

插件作者在发布uniCloud插件、uts/原生插件、前端组件插件时，可自定义售卖价格及形式，见下图：

如未设置价格，则默认为免费插件，所有用户均可免费下载使用；如果想要设置源码授权版价格，则必须设置普通授权版价格。

普通前端插件因其源码开放问题，无法支持计费。

uniCloud插件的云函数部分支持源码保护，未购买源码版的用户无法获取到源码。如果是云端一体插件，其前端部分的js也支持加密混淆。但由于前端js必须运行在前端设备上，仍然存在被破解的可能性，DCloud无法承诺这种前端加密混淆无法破解。

uniCloud插件的销售和服务空间绑定。购买者购买时绑定好自己的服务空间spaceid，未经授权的服务空间无法上传加密的云函数。

uts/app原生插件、前端组件插件，需在使用DCloud的云打包后才能运行（含自定义基座）。所以可以保护版权安全。（也因此，本地打包不支持使用插件市场该类付费插件）

uts/原生插件、前端组件插件的销售，和客户端appid、包名绑定。购买者购买时绑定好自己的appid和包名。未经授权的appid和包名无法运行需要付费购买的插件。

DCloud为所有销售插件提供了试用机制，允许购买者先试用后付费：

用户购买插件后，插件作者可以在销售订单列表 中查看订单流水：

插件收益分为用户付费收益（插件销售、赞赏收益）和广告收益。每天凌晨，系统会自动统计前一天产生的用户付费收益，并于当天下午2：00后统计前一天产生的广告预估收益（可能会有相应的延迟），广告预估收益仅作为参考，实际收益以插件市场后台“付款”栏目提供的月度账单为准。插件作者可登录插件市场后台，查看每天的收益明细。

Tips： 好的插件及更好的售后会增加用户打赏的积极性！

DCloud插件市场在每月1日出上月的月度账单，月度账单包含上月的用户付费收益（包括插件销售、赞赏收益）及上上月的广告收益，待提现的账单累计金额达到100元以上时可提现，如有多笔待提现账单可针对多笔账单进行合并提现。插件作者可登录插件市场后台，查看月度账单 ：

DCloud会收取付费插件和赞赏账单金额的15%做为服务费，然后将剩余款项支付给插件作者，具体参见插件作者协议 。

因财务长期挂账无法处理，插件提现有限期为24个月，即可提现24个月内的账单，请及时关注。

申请提现后，如果账号认证为企业认证，提供发票的途径有线下邮寄和电子发票上传功能，插件作者可在提现记录 中自行上传，电子发票只支持pdf格式：

Tips：为了不影响收益打款，请插件作者在月初尽快提供发票，并完善财务信息

为帮助个人插件作者节税，插件市场引入了云账户，参考云账户介绍 。

---

## uni-app官网

**URL:** https://uniapp.dcloud.net.cn/plugin/publish.html

**Contents:**
- # 制作和发布插件指南
- # 为什么提交插件
- # 插件制作注意
- # 前端组件
  - # 付费前端插件
- # uni-app前端模板
  - # vue/nvue 页面模板
  - # uni-app前端项目模板
- # JS SDK
- # UTS插件

DCloud有活跃的插件市场，https://ext.dcloud.net.cn/ ，并提供了计价销售、广告解锁、赞助、评价等机制。

很多优秀的插件作者，可以做到每月销售数万元的插件。（只有uniCloud插件和App原生或uts插件支持付费，其他类型插件不能设价格）

uni插件其实是uni-app项目下一部分代码，但提交时注意：

从HBuilderX 3.1起，新增 uni_modules，它是uni生态的重要模块化方案。详情另见：https://uniapp.dcloud.net.cn/uni_modules

自uni_modules发布后，建议插件作者首先在自己的项目下建一个uni_modules，在本地开发调试没问题后，对uni_modules下你的插件目录点右键，提交发布到插件市场。

前端组件指uni-app前端使用vue/nvue/wxml等技术开发的、用于页面内嵌的组件。它又进一步细分为vue组件、uvue组件、nvue组件、小程序自定义组件。这个分类不包含uts原生组件。

我们以小明开发的tag组件（插件ID为：xiaoming-tag）为例，上传插件市场时，目录结构要求如下：

为保证代码简洁，上传插件时仅需包含必需的文件及目录。

若组件依赖三方组件，则需将三方组件一起打包上传；假设"xiaoming-tag"依赖小红开发的icon组件（xiaohong-icon），则发布"xiaoming-tag"插件时，目录结构要求如下：

插件市场很早就支持原生插件和uniCloud云插件的加密保护。但前端插件，比如ui库，尤其是可编译到web和小程序的插件，由于其载体的特殊开放性，很难做知识产权保护。

HBuilderX 4.19起，DCloud提供了一种云编译的手段来解决前端插件的知识产权保护问题。

插件作者设置加密后，插件使用者下载到的插件是加密后的版本。在运行、发行对前端代码编译时，uni-app x的编译器会将加密插件发送到DCloud的云编译服务器进行编译，将编译结果混入本地编译工程。从而实现插件使用者可以使用插件但无法获取插件源码的效果。这种云编译仅在第一次进行，云编译一次后会有缓存。

当然插件使用者可以获取到编译后的代码，但就像uni-app (x)编译后的代码非常难懂，更不会有人去改一样，这种方式虽然不严谨但大体上还是有效保护的了前端插件作者的知识产权。

这个过程不会把插件使用者的项目源码整体发送到DCloud服务器，云编译和解密的仅包括加密插件。

插件市场所有加密付费的插件，均有普通授权和源码授权两种版本。如果购买了源码授权，插件作者可以得到插件的完整源码，此时不再发送插件源码到云编译服务器。

不管是普通授权版还是源码授权版，都是绑定唯一的appid和包名。如购买者更换了这2个信息中的一个，需要重新购买授权。注意参考插件购买协议。

通过开发工具、编译器、运行时的整体配合，DCloud给前端插件作者提供了以往不存在的、更为优秀的知识产权保护方案。包括源码授权版，DCloud也会检查盗版行为。

目前前端插件加密，仅支持uni-app x下uni_modules形式的、符合 easycom 规范的组件。插件可在全平台加密，包括web端、app端。

如需发布付费插件，可对插件设置普通授权版及源码授权版的价格。DCloud插件市场会自动加密付费插件中所有vue、uvue、uts、js、ts文件（除pages、hybrid、static目录外）。

HBuilderX发布插件界面暂未支持前端组件价格设置，插件作者可在插件package.json中手动配置价格后提交发布，后续ui上将支持前端组件价格设置。 配置方式参考uni_modules配置 ，在package.jsondcloudext下添加sale销售信息。

前端组件付费插件支持试用，当插件用户试用插件时，无法查阅这些加密的源码。插件试用只能用于本地运行或打包自定义基座，不能用于正式发布。

如果插件用户购买了普通授权版，也看不到这些加密文件的源码，运行或打包时，会提交到云端进行验证、解密及编译。

当项目包含前端付费插件时，首次运行或发行到指定平台时，会触发付费插件在该平台的云端编译，此时需要您的电脑处于联网状态，且您登录的HBuilderX账号需要具备使用该插件的权限（购买、试用、协作等），一旦云端编译成功，后续将使用本地缓存，如果更新了的插件版本、HBuilderX版本或运行时勾选了清除缓存，会再次触发云端编译。

不支持直接引入插件内部的文件，仅支持导入插件根目录

我们以小明开发的设置模板（xiaoming-setting）为例，上传插件市场时，目录结构要求如下：

若页面模板依赖其它组件，则需将依赖组件一起打包；假设"xiaoming-setting"依赖小红开发的list组件（xiaohong-list），则发布"xiaoming-setting"页面模板时，目录结构要求如下：

当然依赖管理，可以使用uni_modules，在你的uni_modules目录下的package.json中配置依赖另一个uni_modules，此时就不用再包含其他插件的源码，但这种做法无法锁定版本，会在使用者下载你的插件时自动安装最新的依赖。

如果你的页面，需要在下载时被注册到使用者的项目的pages.json中，从HBuilderX 3.5.0+ 插件导入工程时，支持合并页面路由到项目的 pages.json。详见

项目模板无特殊要求，注意满足 uni-app 项目目录结构要求即可，详情 Tips：

开发JS SDK时，对目录结构无特殊要求，仅需将js文件命名为插件ID即可，例如：xiaoming-md5.js

如果是非uni_modules的js sdk，使用者下载后会被下载到使用者项目根目录下的js_sdk目录

uts插件开发详见插件开发文档 ，这里主要说明uts付费插件发布的注意事项。

uts付费插件分为普通授权版及源码授权版，两种付费方式区别详见说明文档 。

如需发布付费插件，可对插件设置普通授权版及源码授权版的价格。DCloud插件市场会对付费插件自动加密，付费插件加密规则：

当插件用户试用插件时，无法查阅这些加密的源码。uts插件试用只能用于打包自定义基座，不能用于正式发布。

如果插件用户购买了普通授权版，也看不到这些加密文件的源码，提交云打包时，会在云端验证并解密文件进行打包。

如果插件作者上传插件时，设置了提供源码授权版，且插件使用者购买了源码授权版，才能下载到插件的源码。

不管是普通授权版还是源码授权版，都是绑定唯一的appid和包名。如购买者更换了这2个信息中的一个，需要重新购买授权。

uts插件和App原生插件在功能上是重叠的，都是原生扩展uni-app的能力。

从uts插件发布后，DCloud建议插件作者开发uts插件，替代老的原生插件。

目前uni-app的ext api全部基于uts实现，一些内置api如弹框也已经改成uts实现。虽然对于开发者而言这些并非需要下载的插件，但其实本质是内置于runtime的uts插件。未来uni-app的所有官方api都会改为uts实现。uts的开发体验会优化到最佳。而原生语言插件只会修改较严重的bug。

在未来，uts插件将同时支持下一代的uni-app的uvue，以及现有的vue、nvue。而app原生语言插件只支持这一代的uni-app，无法支持uvue。

包括uts组件，也将支持vue页面。而原生语言插件的组件模式不会支持vue页面，只支持nvue页面。

注意uts插件目前还不支持离线打包，不过插件市场销售的原生语言插件也不支持离线打包。建议有个性化打包需求的开发者使用HBuilderX的cli 来处理自动化打包。

App原生语言插件，需使用Andorid/iOS原生环境开发实现，请参考以下教程：

压缩包格式要求：打开zip后根目录需为插件id目录，二级目录是ios、android子目录及package.json，详情参考uni原生插件包格式

从uts插件发布后，DCloud建议插件作者开发uts插件，替代老的原生插件。原因见上。

HBuilderX插件是安装在HBuilderX工具里的。是编辑器的插件，不是手机App的插件。详细开发教程见：http://hx.dcloud.net.cn/

云函数模板对文件命名没有特殊要求，但制作插件压缩包时，需要注意以下几点：

如果上传付费云函数插件，则必须选择要加密的云函数，否则插件试用者可以通过试用流程无限期使用你的插件而不需要付费。

定义加密云函数，为了与uni_modules统一规范，废弃原encryptlist.json，需在插件根目录下添加package.json，在uni_modules-> encrypt中配置需要加密的文件，如：

示例源码如下，请查看 pre > code 标签中的内容

encrypt数组中可灵活配置uniCloud/cloudfunctions下云函数及公共模块的js文件，与原encryptlist.json文件配置整个云函数或公共模块相比更加灵活。

定义好要加密的云函数内容后，上传插件，DCloud插件市场会自动加密这些云函数。 当插件用户试用插件时，无法查阅这些云函数的源码，并且只有在试用期内（一般是7天内），这些加密云函数才能在他部署的服务空间上运行，过了试用期这些云函数将自动失效。

即便插件用户购买了插件的普通授权版，也看不到这些加密云函数的源码，但这些云函数可以正常运行在他购买时绑定的服务空间上。且无法上传到其他服务空间。

如果插件作者上传插件时，同时提供了源码授权版，且插件使用者购买了源码授权版，才能拿到插件的所有源码。

关于普通授权版和源码授权版的区别，详见：https://ask.dcloud.net.cn/article/38040

从HBuilderX 3.2.0版本开始，当发布云端一体项目模板或云端一体页面模板的付费插件时，前端js文件也支持加密了，设置方式与云函数类似，在uni_modules->encrypt中定义文件路径，如：

示例源码如下，请查看 pre > code 标签中的内容

目前只支持付费插件的js文件加密，vue及nvue文件无法加密，业务核心逻辑建议写到js中。 如果发布云端一体项目且包含uni_modules时，则不会加密uni_modules目录下的文件，uni_modules下应该做为独立插件发布，分别进行加密配置。

如果你的插件配置包含涉密信息，希望保护这些配置不被上传参考：uni_modules插件上传辅助脚本示例

云端一体页面模板，如果非uni_modules，则为单页面模板，只能放一个页面。如果是uni_modules，可以放任意数量页面。

为了防止导入时与项目现有代码冲突，需注意以下几点命名规范：

与uni-app前端项目模板目录结构基本一致，但是必须包含uniCloud相关目录（uniCloud-aliyun、uniCloud-tcb）

在使用uniCloud admin基础框架 后，可以进一步集成插件作者写好的admin插件，以丰富自己的admin系统的功能。 插件作者也可以按此文档提交插件，在插件市场的上传发布页面选择uniCloud 分类的 Admin 插件 。

因文档较长，请单独参阅：uniCloud admin插件开发指南

主要用于提交数据表schema及校验函数，所以必须包含uniCloud-aliyun/database 或 uniCloud-tcb/database目录

如果是非uni_modules插件，那么自己压缩的压缩包注意为标准zip格式，不要使用非主流的压缩软件、不要把rar等其他格式文件的后缀名改名为zip

**Examples:**

Example 1 (unknown):
```unknown
uni_modules
```

Example 2 (unknown):
```unknown
uni_modules
```

Example 3 (unknown):
```unknown
uni_modules
```

Example 4 (unknown):
```unknown
uni_modules
```

---

## uni-app官网

**URL:** https://uniapp.dcloud.net.cn/plugin/uts-ios-spms.html

**Contents:**
- # 在 uts 插件中使用 Swift Package Manager 依赖
- # 基本配置参数
- # dependencies-spms 配置参数
- # name 字段详细说明
  - # 1. Package.swift 中的定义
  - # 2. config.json 中的配置
- # kind 类型详细说明
  - # 版本范围说明
- # 实际项目示例
  - # 示例 1：Alamofire

本文旨在帮助 uts 插件开发者和使用者，快速了解 uts 插件中配置使用 Swift Package Manager 依赖的问题。

此功能 HBuilder X 5.0+ 版本支持

在 uts 插件中使用 Swift Package Manager 依赖库，需要在 config.json 中 dependencies-spms 节点做相应配置，下面是配置示例：

示例源码如下，请查看 pre > code 标签中的内容

⚠️ 重要提醒：name 字段配置错误会导致 UTS 插件编译失败！必须使用 Package.swift 中 products 数组里定义的 library name，而不是包名。

name 字段需要配置为 Swift Package 中定义的产品名称，请查看三方库git地址根目录中Package.swift文件（如果三方库支持spm），具体对应关系如下：

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

每个 Swift 包在根目录下有一个 Package.swift，其中包含平台支持声明：

示例源码如下，请查看 pre > code 标签中的内容

**Examples:**

Example 1 (json):
```json
{
	"deploymentTarget": "12.0",   // 可选，插件支持的最低 iOS 版本  默认：12.0
	"dependencies-spms": [ // 可选, 需要依赖的 Swift Package Manager 库, HBuilderX 5.0+ 版本支持
	// 1. exactVersion - 精确版本匹配：
	{
		"name": "Alamofire",
		"url": "https://github.com/Alamofire/Alamofire.git",
		"kind": "exactVersion",
		"version": "5.7.1"
	},

	// 2. upToNextMajorVersion - 默认最常用：
	{
		"name": "Alamofire", 
		"url": "https://github.com/Alamofire/Alamofire.git",
		"kind": "upToNextMajorVersion",
		"minimumVersion": "5.7.1"
	},

	// 3. upToNextMinorVersion - 小版本兼容：
	{
		"name": "Alamofire",
		"url": "https://github.com/Alamofire/Alamofire.git", 
		"kind": "upToNextMinorVersion",
		"minimumVersion": "5.7.1"
	},

	// 4. versionRange - 版本区间：
	{
		"name": "Alamofire",
		"url": "https://github.com/Alamofire/Alamofire.git",
		"kind": "versionRange", 
		"minimumVersion": "5.7.1",
		"maximumVersion": "5.7.8"
	},

	// 5. branch - 分支跟踪：
	{
		"name": "Alamofire",
		"url": "https://github.com/Alamofire/Alamofire.git",
		"kind": "branch",
		"branch": "main"
	},

	// 6. revision - 提交锁定：
	{
		"name": "Alamofire",
		"url": "https://github.com/Alamofire/Alamofire.git", 
		"kind": "revision",
		"revision": "2053b120767c42a70bcba21095f34e4cfb54a75d"
	}]
}
```

Example 2 (json):
```json
{
	"deploymentTarget": "12.0",   // 可选，插件支持的最低 iOS 版本  默认：12.0
	"dependencies-spms": [ // 可选, 需要依赖的 Swift Package Manager 库, HBuilderX 5.0+ 版本支持
	// 1. exactVersion - 精确版本匹配：
	{
		"name": "Alamofire",
		"url": "https://github.com/Alamofire/Alamofire.git",
		"kind": "exactVersion",
		"version": "5.7.1"
	},

	// 2. upToNextMajorVersion - 默认最常用：
	{
		"name": "Alamofire", 
		"url": "https://github.com/Alamofire/Alamofire.git",
		"kind": "upToNextMajorVersion",
		"minimumVersion": "5.7.1"
	},

	// 3. upToNextMinorVersion - 小版本兼容：
	{
		"name": "Alamofire",
		"url": "https://github.com/Alamofire/Alamofire.git", 
		"kind": "upToNextMinorVersion",
		"minimumVersion": "5.7.1"
	},

	// 4. versionRange - 版本区间：
	{
		"name": "Alamofire",
		"url": "https://github.com/Alamofire/Alamofire.git",
		"kind": "versionRange", 
		"minimumVersion": "5.7.1",
		"maximumVersion": "5.7.8"
	},

	// 5. branch - 分支跟踪：
	{
		"name": "Alamofire",
		"url": "https://github.com/Alamofire/Alamofire.git",
		"kind": "branch",
		"branch": "main"
	},

	// 6. revision - 提交锁定：
	{
		"name": "Alamofire",
		"url": "https://github.com/Alamofire/Alamofire.git", 
		"kind": "revision",
		"revision": "2053b120767c42a70bcba21095f34e4cfb54a75d"
	}]
}
```

Example 3 (json):
```json
{
	"deploymentTarget": "12.0",   // 可选，插件支持的最低 iOS 版本  默认：12.0
	"dependencies-spms": [ // 可选, 需要依赖的 Swift Package Manager 库, HBuilderX 5.0+ 版本支持
	// 1. exactVersion - 精确版本匹配：
	{
		"name": "Alamofire",
		"url": "https://github.com/Alamofire/Alamofire.git",
		"kind": "exactVersion",
		"version": "5.7.1"
	},

	// 2. upToNextMajorVersion - 默认最常用：
	{
		"name": "Alamofire", 
		"url": "https://github.com/Alamofire/Alamofire.git",
		"kind": "upToNextMajorVersion",
		"minimumVersion": "5.7.1"
	},

	// 3. upToNextMinorVersion - 小版本兼容：
	{
		"name": "Alamofire",
		"url": "https://github.com/Alamofire/Alamofire.git", 
		"kind": "upToNextMinorVersion",
		"minimumVersion": "5.7.1"
	},

	// 4. versionRange - 版本区间：
	{
		"name": "Alamofire",
		"url": "https://github.com/Alamofire/Alamofire.git",
		"kind": "versionRange", 
		"minimumVersion": "5.7.1",
		"maximumVersion": "5.7.8"
	},

	// 5. branch - 分支跟踪：
	{
		"name": "Alamofire",
		"url": "https://github.com/Alamofire/Alamofire.git",
		"kind": "branch",
		"branch": "main"
	},

	// 6. revision - 提交锁定：
	{
		"name": "Alamofire",
		"url": "https://github.com/Alamofire/Alamofire.git", 
		"kind": "revision",
		"revision": "2053b120767c42a70bcba21095f34e4cfb54a75d"
	}]
}
```

Example 4 (json):
```json
{
	"deploymentTarget": "12.0",   // 可选，插件支持的最低 iOS 版本  默认：12.0
	"dependencies-spms": [ // 可选, 需要依赖的 Swift Package Manager 库, HBuilderX 5.0+ 版本支持
	// 1. exactVersion - 精确版本匹配：
	{
		"name": "Alamofire",
		"url": "https://github.com/Alamofire/Alamofire.git",
		"kind": "exactVersion",
		"version": "5.7.1"
	},

	// 2. upToNextMajorVersion - 默认最常用：
	{
		"name": "Alamofire", 
		"url": "https://github.com/Alamofire/Alamofire.git",
		"kind": "upToNextMajorVersion",
		"minimumVersion": "5.7.1"
	},

	// 3. upToNextMinorVersion - 小版本兼容：
	{
		"name": "Alamofire",
		"url": "https://github.com/Alamofire/Alamofire.git", 
		"kind": "upToNextMinorVersion",
		"minimumVersion": "5.7.1"
	},

	// 4. versionRange - 版本区间：
	{
		"name": "Alamofire",
		"url": "https://github.com/Alamofire/Alamofire.git",
		"kind": "versionRange", 
		"minimumVersion": "5.7.1",
		"maximumVersion": "5.7.8"
	},

	// 5. branch - 分支跟踪：
	{
		"name": "Alamofire",
		"url": "https://github.com/Alamofire/Alamofire.git",
		"kind": "branch",
		"branch": "main"
	},

	// 6. revision - 提交锁定：
	{
		"name": "Alamofire",
		"url": "https://github.com/Alamofire/Alamofire.git", 
		"kind": "revision",
		"revision": "2053b120767c42a70bcba21095f34e4cfb54a75d"
	}]
}
```

---

## uni-app官网

**URL:** https://uniapp.dcloud.net.cn/plugin/language.html

**Contents:**
- # uni-app及uniCloud分类
- # HBuilderX分类
      - 本页导读

插件支持多语言是基于uni-app国际化 及HBuilderX插件国际化 规范延伸而来的，所以不同类型的插件多语言规范略有不同。

参考HBuilderX插件国际化 规范教程，根据插件根目录下package.nls.[语言代码].json进行识别，如插件除默认语言之外支持英语及日语，插件包则需要包含如下文件：

示例源码如下，请查看 pre > code 标签中的内容

其中语言代码必须符合规范，点击查看更多语言代码

**Examples:**

Example 1 (unknown):
```unknown
插件根目录
├── package.json
├── package.nls.en.json
├── package.nls.json
└── package.nls.ja.json
```

Example 2 (unknown):
```unknown
插件根目录
├── package.json
├── package.nls.en.json
├── package.nls.json
└── package.nls.ja.json
```

Example 3 (unknown):
```unknown
插件根目录
├── package.json
├── package.nls.en.json
├── package.nls.json
└── package.nls.ja.json
```

Example 4 (unknown):
```unknown
插件根目录
├── package.json
├── package.nls.en.json
├── package.nls.json
└── package.nls.ja.json
```

---

## uni-app官网

**URL:** https://uniapp.dcloud.net.cn/plugin/oath.html

**Contents:**
      - 本页导读

DCloud用户开放平台，https://open.dcloud.net.cn ，是DCloud为三方开发者服务商提供的开放平台。

DCloud将数百万开发者的流量通过开放平台提供给三方开发者服务商。

让每个为开发者服务的公司，快速分享DCloud的开发者流量。

使用文档参考：https://ask.dcloud.net.cn/article/38005

---

## uni-app官网

**URL:** https://uniapp.dcloud.net.cn/plugin/

**Contents:**
      - 本页导读

uni-app积极拥抱社区，创建了开放、兼容的插件系统。

uni-app插件市场，https://ext.dcloud.net.cn ，是uni-app官方插件生态集中地。有数千款插件，支持前端组件、js sdk、页面模板、项目模板、原生插件等多种类型。在生态建设上远远领先于竞品。请注意尽量在官方市场寻找插件，npm等三方市场没有uni-app兼容性描述，很容易下载到无法跨平台的、仅适配web的插件。

小程序生态内容可直接引入uni-app，并且在App侧通用。以前的跨平台开发框架普遍缺少三方SDK，由于大量SDK厂商均原厂维护小程序SDK，使得uni-app成为跨平台开发框架里生态最丰富的平台参考

小程序自定义组件是一种ui组件，uni-app里可以在App、H5、微信小程序、QQ小程序同时兼容微信小程序自定义组件，参考

uni-app支持npm包，但注意npm下载的插件很可能不是全端的，大多npm插件仅适配了web。需要全端插件还是要去uni-app插件市场https://ext.dcloud.net.cn 去找。

uni-app内置了weex，weex的原生插件或ui库均可使用。注意weex的生态不如uni-app丰富，一般情况建议使用uni-app的插件市场。

uni-app的H5端支持所有浏览器API。但众所周知，由于小程序的js不运行在浏览器里，所以小程序里不支持 HTML 和 DOM 的 API。

uni-app的App端虽然和小程序是相同的架构，逻辑层也运行在独立jscore而不是浏览器里，但App端和小程序还是有区别的： * 一方面可通过web-view组件加载本地HTML，引入web相关库； * 另一方面可通过renderjs实现在渲染层执行js，此时完整echart、threejs等web库均可使用。 （但为了全端使用，仍然建议减少对dom库的依赖，在uni-app的插件市场可寻找全端兼容的库来替代）

---

## uni-app官网

**URL:** https://uniapp.dcloud.net.cn/plugin/uts-plugin-hybrid.html

**Contents:**
- # UTS原生混编介绍
- # UTS原生混编的优势和使用场景
    - # 前置条件
- # Android平台
    - # 第一步 获取和验证原生代码
    - # 第二步 集成原生代码
    - # 第三步 在原生代码中调用UTS内置对象
      - # uts和kotlin对象映射表
    - # 第四步 编写UTS调用原生代码
- # iOS平台

UTS插件中（具体是uni_modules下的utssdk目录），支持app-Android、app-iOS、app-harmony、web、mp-weixin等平台专用目录。 这些专用目录，可以直接放置原生的kotlin、java、swift、ArkTS代码，和uts代码混合使用，即 UTS原生混编(下文简称：原生混编)

UTS插件的入口仍然是uts代码，但在uts代码里，可以直接调用插件下的kotlin、swift代码中的函数、对象。

在UTS插件的编译流程中，UTS本身就会被编译为Kotlin/swift/ArkTS 源码。所以 UTS 调用原生代码的过程，本质是同一语言内部，不同函数/对象之间的调用过程，无缝且不会有任何序列化等性能损耗

同时在HBuilderX的真机运行中，可以直接改动uts或kotlin、swift、ArkTS代码、整体联编、直接运行，无需打包自定义基座。（java代码仍需打包自定义基座）

甚至在原生代码中，也可以使用console.log，把日志打印在HBuilderX的控制台中。

原生混编出现之前，开发者只能使用UTS语言 来开发UTS插件

不管是网上搜的还是历史存留的，当涉及到原生的kotlin、java、swift、ArkTS代码时，开发者要不把这些代码自行翻译成uts代码，要不把这些代码封装成aar、framework等包，再被uts引用。

有时会遇到uts还不支持的语法，只能使用原生语言，就必须封装库了。

如原生代码数量较多，则翻译比较吃力；如封装成aar等库，每次改动都需要打自定义基座，也很麻烦。

开发者只需要把 Kotlin/swift/java/ArkTS 代码放在UTS插件目录中，就可以通过 UTS直接使用这些代码。

并且和uts代码一样，混编的原生代码（除java）可以直接真机运行，省去了手动集成AAR等三方库后打包自定义基座的环节，提升了开发效率。

下面我们以内存监控功能为例，分别拆解 UTS原生混编技术在Android和ios平台上的使用步骤

在开始使用 UTS原生混编之前，开发者需要确保两个前置条件：

1 HBuidlerX 4.25 以上版本

在进行下一步的操作之前，你的目录应该是这样的：

AI工具或官方文档得到的代码并不总是准确的，我们需要去验证它。

目前HBuilderX并未提供原生代码的语法提示和校验，因此我们建议：

如果编写大段原生代码，推荐在原生IDE(比如：AndroidStudio)中编写，再放入UTS插件混编联调

如果是小的代码片段，可以直接放入UTS插件目录，依靠HBuilderX本地编译和打log功能来完成原生代码的校验

这里我们选择直接集成UTS插件, 使用HBuilderX来验证

Kotlin/Java语言中，存在包名 的概念，类似swift的命名空间。为了让我们的原生代码可以被UTS使用，我们需要确保原生代码的包名是正确的:

大多数情况下，我们建议混编代码的包名与UTS插件默认包名 保持一致，这样在UTS调用原生代码时，可以省去手动引入包名的步骤。

示例源码如下，请查看 pre > code 标签中的内容

如果混编代码的包名与UTS插件默认包名不一致，则需要像使用原生对象一样手动引入

示例源码如下，请查看 pre > code 标签中的内容

回到我们的示例，现在整理完的Kotlin代码是这样的：

示例源码如下，请查看 pre > code 标签中的内容

上面的代码中，我们将获取内存的信息的功能以Kotlin静态方法MemoryInfoNative.getMemInfoKotlin() 的形式对外暴露

接下来，我们将整理好的原生代码添加到 在 app-android 目录下的 MemoryInfoNative.kt 中：

示例源码如下，请查看 pre > code 标签中的内容

注意：java代码需要云打包自定义基座后生效，kotlin代码不需要打包，标准基座即可生效

是的，就是这样简单。如图所示，我们已经完成了对原生代码的集成。

为了让原生代码中方便调用UTS的内置对象，尤其是用于数据类型转换。官方提供了在原生代码调用UTS对象的方法。

UTS的内置对象和平台专用对象均可以在原生环境使用，下面以kotlin中打印日志到HBuilder X 控制台为例说明：

第一步：手动导入对应的包名，包名规则为： io.dcloud.uts.xxx 。这里的 xxx 是具体的对象的类名 ：

示例源码如下，请查看 pre > code 标签中的内容

第二步： 导入包名后，以原生方式使用内置对象

示例源码如下，请查看 pre > code 标签中的内容

这样就实现了在kt或java代码中打印日志到HBuilderX的控制台。

不过这个导入和使用过程将没有代码提示，输出的变量信息也不会包含变量所在的文件和代码行号等信息。

下面列出内置对象对应的类名，如果需要在原生环境和UTS环境/uvue环境中互传数据，建议转换为标准内置对象实现后再进行传递。

在上面的示例中，已经实现了获取当前系统内存的功能，如果还想更进一步持续监控内存变化，并通过回调返回数据。

实现持续调用的方法有很多，这里我们为了演示在Kotlin代码中调用UTS内置对象的情况，选择采用setInterval来实现这个功能:

UTS内置对象在具体的平台会有一个对应的类名，举例： UTS内置的Array 对应 Kotlin中的io.dcloud.uts.UTSArray

当前示例中不涉及，但如果开发者可能遇到类似 kotlin.Array 转换 UTS内置Array的情况，这种情况可以通过查阅内置对象文档来解决。

完整的内置对象实现清单和与原生对象转换代码示例，大家都可以在内置对象文档的具体章节找到

示例源码如下，请查看 pre > code 标签中的内容

上面的代码中，我们将监听内存变化的功能以Kotlin静态方法MemoryInfoNative.onMemoryInfoChangeKotlin(callback) 的形式对外暴露。

注意：这里的 callback 类型为 (Array<Number>) -> Unit, 其中参数为 Number 数组类型（注：这里的数组为kotlin.Array，与 uts 中的数组有区别），无返回值（类型为Unit）。

至此，内存监控功能的原生代码部分已经完全开发完毕。接下来，我们编写UTS代码来使用它。

如我们在前文所讲，UTS是Kotlin语言的上游语言。所有Kotlin代码中的：类、对象、函数、变量，均可以在uts中直接使用。

因为UTS的编译器兼容了Kotlin的语法规则，所以UTS中调用Kotlin代码可以被很好的支持，即使升级HBuilderX版本也不会有什么问题。

但UTS从未保证过编译Kotlin的具体规则。所以虽然开发者可以通过一些取巧的方式实现 在Kotlin中调用UTS代码，但这是不安全的，HBuilderX升级后，类似的代码可能会失效/异常。

在示例里 uni-MemoryInfo/utssdk/app-android/index.uts 文件中，使用 uts 代码封装为插件导出 API：

示例源码如下，请查看 pre > code 标签中的内容

上面的代码，我们在UTS中使用 Array.fromNative(kotlinArray) 将 kotlin 数组转换为 uts 数组。

在进行下一步的操作之前，你的目录应该是这样的：

AI工具或官方文档得到的代码并不总是准确的，我们需要去验证它。

目前HBuilderX并未提供原生代码的语法提示和校验，因此我们建议：

如果编写大段原生代码，推荐在原生IDE(比如：Xcode)中编写验证，再放入UTS插件混编联调

如果是小的代码片段，可以直接放入UTS插件目录，依靠HBuilderX本地编译和打log功能来完成原生代码的校验

这里我们选择直接集成UTS插件, 使用HBuilderX来验证

swift 文件默认会引入原生系统库 Foundation, 如果需要调用 UI 相关的代码，则需要引入 UIKit,

如果你需要使用 uts 内置对象，则需要引入 uts 基础库 DCloudUTSFoundation。

回到我们的示例，现在整理完的swift代码是这样的：

示例源码如下，请查看 pre > code 标签中的内容

上面的代码中，我们将获取内存的信息的功能以swift静态方法MemoryInfoNative.getMemInfoSwift() 的形式对外暴露。 而获取内存信息具体功能的实现，则是由两个原生方法getTotalMemory、getFreeMemory实现。

接下来，我们将整理好的原生代码添加到 在 app-ios 目录下的 MemoryInfoNative.swift 中：

示例源码如下，请查看 pre > code 标签中的内容

是的，就是这样简单。如图所示，我们已经完成了对原生代码的集成。

UTS的内置对象和平台专用对象均可以在原生环境使用， 但是在使用前需要导入基础库 DCloudUTSFoundation。

首先将基础库 DCloudUTSFoundation 导入到 swift 源码文件中，不过这个导入和使用过程将没有代码提示，输出的变量信息也不会包含变量所在的文件和代码行号等信息。

示例源码如下，请查看 pre > code 标签中的内容

如果你想在 swift 代码中使用 UTSiOS 对象提供的能力，你需要先导入基础库 DCloudUniappRuntime.

示例源码如下，请查看 pre > code 标签中的内容

我们知道在 uts 中使用的 uts 内置对象会被编成原生类型，那么在混编的 swift 文件中要想使用 uts 内置对象，就要直接使用其编译后的原生类型。 下面列出 uts 内置对象对应的 swift 原生类名

在上面的示例中，已经实现了获取当前系统内存的功能，如果还想更进一步持续监控内存变化，并通过回调返回数据。

实现持续调用的方法有很多,这里我们为了演示在swift代码中调用UTS内置对象的情况，选择采用setInterval来实现这个功能:

UTS内置对象在具体的平台会有一个对应的类名，举例： UTS内置的Set 对应 swift中的UTSSet

2 正确的处理原生对象和内置对象直接的转换

下面的示例代码中涉及到 uts 内置对象 Number 转换成原生类型 Int 的例子，实现方式为 toInt(), 具体见示例代码。如果你遇到其他类型的转换，请查阅内置对象文档来确定转换方法。

完整的内置对象实现清单和与原生对象转换代码示例，大家都可以在内置对象文档的具体章节找到

示例源码如下，请查看 pre > code 标签中的内容

上面的代码中，我们将获取内存的信息的功能以swift静态方法NativeCode.startMemMonitor(callback) 的形式对外暴露。

这里的 callback参数是一个 参数为[Int](即 Array<Int>) 类型的 swift函数，对应UTS中一个参数为Array的function对象

至此，内存监控功能的原生代码部分已经完全开发完毕。接下来，我们编写UTS代码来使用它。

如我们在前文所讲，UTS是swift语言的上游语言。所有swift代码中的：类、对象、函数、变量，均可以在uts中直接使用。

因为UTS的编译器兼容了swift的语法规则，所以UTS中调用swift代码可以被很好的支持，即使升级 HBuilderX 版本也不会有什么问题。

但UTS从未保证过编译对应的swift的具体规则。所以虽然开发者可以通过一些取巧的方式实现：swift 中调用 UTS 代码，但这是不安全的。HBuilderX 版本升级后，类似代码可能会失效或者异常。

在我们的示例中, UTS 中的调用的代码是这样的：

示例源码如下，请查看 pre > code 标签中的内容

上面的代码，我们在UTS中使用 Number.from(value) 将 swift 中 Int 转换为 uts 中的 number 类型。

uts、ets文件依赖js新增于HBuilderX 4.61版本

示例源码如下，请查看 pre > code 标签中的内容

UTSJSONObject不会对对象字面量进行深层转换

示例源码如下，请查看 pre > code 标签中的内容

如下示例使用的uni_module目录结构如下

示例源码如下，请查看 pre > code 标签中的内容

鸿蒙平台使用uts插件时，uts文件可以依赖ets文件、js文件、本地har包以及ohpm上的包。

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

需要注意的是ets文件不能引用uts文件，js文件不能引用ets文件及uts文件。如果有ets引用uts内的对象的需求，可以通过一个js文件进行中转。示例如下：

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

UTS与uvue之间的相互调用，属于UTS插件开发的相关内容，这里不展开叙述，开发者可以查阅相关文档掌握这部分知识。

示例源码如下，请查看 pre > code 标签中的内容

在uts编译为js时，uts和js可以任意混编，就像ts和js可以互相引用一样。

示例源码如下，请查看 pre > code 标签中的内容

示例源码如下，请查看 pre > code 标签中的内容

index是保留文件名，原生代码不能命名为 index.kt/index.java/index.swift

HBuilder X 暂不支持原生代码的语法提示、转到定义。仅支持高亮和格式化。

示例源码如下，请查看 pre > code 标签中的内容

**Examples:**

Example 1 (unknown):
```unknown
AndroidStudio
```

Example 2 (kotlin):
```kotlin
// 如 uts 插件目录为 uni-MemoryInfo 时默认混编代码的包名为
package uts.sdk.modules.uniMemoryInfo
```

Example 3 (kotlin):
```kotlin
// 如 uts 插件目录为 uni-MemoryInfo 时默认混编代码的包名为
package uts.sdk.modules.uniMemoryInfo
```

Example 4 (kotlin):
```kotlin
// 如 uts 插件目录为 uni-MemoryInfo 时默认混编代码的包名为
package uts.sdk.modules.uniMemoryInfo
```

---
